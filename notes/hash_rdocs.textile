# -*- coding: utf-8 -*-

# Hashlike#store
#
# Element Assignment---Associates the value given by value with the key given
# by key. key should not have its value changed while it is in use as a key (a
# String passed as a key will be duplicated and frozen).
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh[:a] = 9
#     hsh[:c] = 4
#     hsh    # => { :a => 9, :b => 200, :c => 4 }
#
#     hsh[key] = val                         -> val
#     hsh.store(key, val)                    -> val
#
# @param  key [Object] key to associate
# @param  val [Object] value to associate it with
# @return [Object]


# Hashlike#delete
#
# Deletes and returns a key-value pair from hsh whose key is equal to key. If
# the key is not found, returns the default value. If the optional code block
# is given and the key is not found, pass in the key and return the result of
# block.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.delete(:a)                            # => 100
#     hsh.delete(:z)                            # => nil
#     hsh.delete(:z){|el| "#{el} not found" }   # => "z not found"
#
# @overload hsh.delete(key)                  -> val
#   @param  key [Object] key to remove
#   @return [Object, Nil] the removed object, nil if missing
#
# @overload hsh.delete(key){|key| block }    -> val
#   @param  key [Object] key to remove
#   @yield  [Object] called (with key) if key is missing
#   @yieldparam key
#   @return [Object, Nil] the removed object, or if missing, the return value
#     of the block


# Hashlike#keys
#
# Returns a new array populated with the keys from this hashlike.
#
# @see Hashlike#values.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300, :d => 400 }
#     hsh.keys   # => [:a, :b, :c, :d]
#
# @return [Array] list of keys


# Hashlike#each
#
# Calls block once for each key in hsh, passing the key-value pair as
# parameters.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each{|key, value| puts "#{key} is #{value}" }
#     # produces:
#     a is 100
#     b is 200
#
# @overload hsh.each{|key, val| block }      -> hsh
#   Calls block once for each key in hsh
#   @yield [key, val] in order, each key and its associated value
#   @return [Hashlike]
#
# @overload hsh.each                         -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#

# Hashlike#each_key
#
# Calls block once for each key in hsh, passing the key as a parameter.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each_key{|key| puts key }
#     # produces:
#     a
#     b
#
# @overload hsh.each_key{|key| block }       -> hsh
#   Calls block once for each key in hsh
#   @yield [key] in order, each key
#   @return [Hashlike]
#
# @overload hsh.each_key                     -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#each_value
#
# Calls block once for each key in hsh, passing the value as a parameter.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.each_value{|value| puts value }
#
#     produces:
#
#     100
#     200
#
# @overload hsh.each_value{|val| block }     -> hsh
#   Calls block once for each value in hsh
#   @yield [val] in order by its key, each value
#   @return [Hashlike]
#
# @overload hsh.each_value                   -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#has_key?
#
# Returns true if the given key is present in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise


# Hashlike#include?
#
# Returns true if the given key is present in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise


# Hashlike#key?
#
# Returns true if the given key is present in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise


# Hashlike#member?
#
# Returns true if the given key is present in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_key?(:a)   # => true
#     hsh.has_key?(:z)   # => false
#
# @param key [Object] the key to query
# @return [true, false] true if the key is present, false otherwise


# Hashlike#has_value?
#
# Returns true if the given value is present for some key in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_value?(100)   # => true
#     hsh.has_value?(999)   # => false
#
# @param  val [Object] the value to query
# @return [true, false] true if the value is present, false otherwise


# Hashlike#value?
#
# Returns true if the given value is present for some key in hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.has_value?(100)   # => true
#     hsh.has_value?(999)   # => false
#
# @param  val [Object] the value to query
# @return [true, false] true if the value is present, false otherwise


# Hashlike#fetch
#
# Returns a value from the hashlike for the given key. If the key can't be found,
# there are several options: With no other arguments, it will raise an
# KeyError exception; if default is given, then that will be
# returned; if the optional code block is specified, then that will be run and
# its result returned.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.fetch(:a)                          # => 100
#     hsh.fetch(:z, "go fish")               # => "go fish"
#     hsh.fetch(:z){|el| "go fish, #{el}"}   # => "go fish, z"
#
# The following example shows that an exception is raised if the key is not
# found and a default value is not supplied.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.fetch(:z)
#     # produces:
#     prog.rb:2:in `fetch': key not found (KeyError) from prog.rb:2
#
#     hsh.fetch(:z, 3)
#     # => 3
#
#     hsh.fetch(:z){|key| key.to_s * 5 }
#     # => "zzzzz"
#
# @param key     [Object] the key to query
# @param default [Object] the value to use if the key is missing
# @yield         [key]    if missing, block called with the key requested
# @return        [Object] the value; if missing, the default; if missing, the
#                         block's return value


# Hashlike#length
#
# Returns the number of key-value pairs in the hashlike.
#
# @example
#     hsh = { :d => 100, :a => 200, :v => 300, :e => 400 }
#     hsh.length       # => 4
#     hsh.delete(:a)   # => 200
#     hsh.length       # => 3
#
# @return [Fixnum] number of key-value pairs
#


# Hashlike#empty?
#
# Returns true if hsh contains no key-value pairs.
#
# @example
#     {}.empty?   # => true
#
# @return [true, false] true if hsh contains no key-value pairs, false otherwise
#

# Hashlike#to_hash
#
# Returns a hash with each key set to its associated value.
#
# @example
#    my_hshlike = MyHashlike.new
#    my_hshlike[:a] = 100; my_hshlike[:b] = 200
#    my_hshlike.to_hash # => { :a => 100, :b => 200 }
#
# @return [Hash]
#


# Hashlike#values
#
# Returns a new array populated with the values from hsh.
#
# @see Hashlike#keys.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.values   # => [100, 200, 300]
#
# @return [Array] the values, in order by their key
#


# Hashlike#values_at
#
# Return an array containing the values associated with the given keys.
#
# @see Hashlike#select.
#
# @example
#     hsh = { "cat" => "feline", "dog" => "canine", "cow" => "bovine" }
#     hsh.values_at("cow", "cat")  # => ["bovine", "feline"]
#
# @param  *allowed_keys [Object] the keys to retrieve
# @return [Array] the values, in order according to allowed_keys
#

# Hashlike#key
#
# Returns the key for a given value. If not found, returns nil.
#
# @example
#     hsh = { :a => 100, :b => 200 }
#     hsh.key(200)   # => :b
#     hsh.key(999)   # => nil
#
# @param  val [Object] the value to look up
# @return [Object, nil] the key for the given val, or nil if missing
#

# Hashlike#invert
#
# Returns a new hash created by using hsh's values as keys, and the keys as
# values. If hsh has duplicate values, the result will contain only one of
# them as a key -- which one is not predictable.
#
# @example
#     hsh = { :n => 100, :m => 100, :y => 300, :d => 200, :a => 0 }
#     hsh.invert # => { 0 => :a, 100 => :m, 200 => :d, 300 => :y }
#
# @return [Hash] a new hash, with values for keys and vice-versa
#


# Hashlike#delete_if
#
# Deletes every key-value pair from hsh for which block evaluates
# to true.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "z" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.delete_if{|key, val| block } -> hsh
#   Deletes every key-value pair from hsh for which block evaluates to true.
#   @return [Hashlike]
#
# @overload hsh.delete_if                    -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#reject!
#
# Deletes every key-value pair from hsh for which block evaluates to true.
# (Equivalent to Hashlike#delete_if), but returns nil if no changes were made.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.delete_if{|key, val| key.to_s >= "z" }   # nil
#
# @overload hsh.reject!{|key, val| block }   -> hsh or nil
#   Deletes every key-value pair from hsh for which block evaluates to true.
#   @return [Hashlike, nil]
#
# @overload hsh.reject!                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#reject
#
# Same as Hashlike#delete_if, but works on (and returns) a copy of the
# hsh. Equivalent to hsh.dup.delete_if.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.reject{|key, val| key.to_s >= "b" }   # => { :a => 100 }
#     hsh # => { :a => 100, :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.reject{|key, val| key.to_s >= "z" }   # => { :a => 100, :b => 200, :c => 300 }
#     hsh # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.reject{|key, val| block }    -> new_hashlike
#   Deletes every key-value pair from hsh for which block evaluates to true.
#   @return [Hashlike]
#
# @overload hsh.reject                       -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#

# Hashlike#keep_if
#
# Deletes every key-value pair from hsh for which block evaluates to false.
#
# If no block is given, an enumerator is returned instead.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.keep_if{|key, val| key.to_s >= "b" }   # => { :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.keep_if{|key, val| key.to_s >= "a" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.keep_if{|key, val| block }   -> hsh
#   Deletes every key-value pair from hsh for which block evaluates to false.
#   @return [Hashlike]
#
# @overload hsh.keep_if                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#select!
#
# Equivalent to Hashlike#keep_if, but returns nil if no changes were
# made.
#
# @example
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.select!{|key, val| key.to_s >= "b" }   # => { :b => 200, :c => 300 }
#
#     hsh = { :a => 100, :b => 200, :c => 300 }
#     hsh.select!{|key, val| key.to_s >= "a" }   # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.select!{|key, val| block }   -> hsh or nil
#   Deletes every key-value pair from hsh for which block evaluates to false.
#   @return [Hashlike]
#
# @overload hsh.select!                      -> an_enumerator
#   with no block, returns a raw enumerator
#   @return [Enumerator]
#


# Hashlike#clear
#
# Removes all key-value pairs from hsh.
#
# @example
#     hsh = { :a => 100, :b => 200 }   # => { :a => 100, :b => 200 }
#     hsh.clear                        # => {}
#
# @return [Hashlike] this hashlike, emptied
#


# Hashlike#assoc
#
# Searches through the hashlike comparing obj with the key using ==.
# Returns the key-value pair (two elements array) or nil if no match is
# found.
#
# @see Array#assoc.
#
# @example
#     hsh = { "colors"  => ["red", "blue", "green"],
#             "letters" => [:a, :b, :c ]}
#     hsh.assoc("letters")  # => ["letters", [:a, :b, :c]]
#     hsh.assoc("foo")      # => nil
#
# @return [Array, nil] the key-value pair (two elements array) or nil if no
#   match is found.
#


# Hashlike#rassoc
#
# Searches through the hashlike comparing obj with the value using ==.
# Returns the first key-value pair (two-element array) that matches.
#
# @see Array#rassoc.
#
# @example
#     hsh = { 1 => "one", 2 => "two", 3 => "three", "ii" => "two"}
#     hsh.rassoc("two")    # => [2, "two"]
#     hsh.rassoc("four")   # => nil
#
# @return [Array, nil] The first key-value pair (two-element array) that
#   matches, or nil if no match is found
#


# Hashlike#flatten
#
# Returns a new array that is a one-dimensional flattening of this hashlike. That
# is, for every key or value that is an array, extract its elements into the
# new array.  Unlike Array#flatten, this method does not flatten recursively
# by default.  The optional level argument determines the level of recursion
# to flatten.
#
# @example
#     hsh =  {1=> "one", 2 => [2,"two"], 3 => "three"}
#     hsh.flatten    # => [1, "one", 2, [2, "two"], 3, "three"]
#     hsh.flatten(2) # => [1, "one", 2, 2, "two", 3, "three"]
#
# @example
#     hsh = { [1, 2, [3, 4]] => [1, [2, 3, [4, 5, 6]]] }
#     hsh.flatten
#     # =>   [[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]
#     hsh.flatten(0)
#     # =>  [[[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]]
#     hsh.flatten(1)
#     # =>   [[1, 2, [3, 4]],   [1, [2, 3, [4, 5, 6]]]]
#     hsh.flatten(2)
#     # =>    [1, 2, [3, 4],     1, [2, 3, [4, 5, 6]]]
#     hsh.flatten(3)
#     # =>    [1, 2,  3, 4,      1,  2, 3, [4, 5, 6]]
#     hsh.flatten(4)
#     # =>    [1, 2,  3, 4,      1,  2, 3,  4, 5, 6]
#
# @param  level [Integer] the level of recursion to flatten, 0 by default.
# @return [Array] the flattened key-value array.
#


# Hashlike#update
#
# Adds the contents of other_hash to hsh.  If no block is
# specified, entries with duplicate keys are overwritten with the values from
# other_hash, otherwise the value of each duplicate key is determined by
# calling the block with the key, its value in hsh and its value in
# other_hash.
#
# @example
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge!(h2)
#     # => { :a => 100, :b => 254, :c => 300 }
#
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge!(h2){|key, v1, v2| v1 }
#     # => { :a => 100, :b => 200, :c => 300 }
#
# @overload hsh.update(other_hash)                               -> hsh
#   Adds the contents of other_hash to hsh.  Entries with duplicate keys are
#   overwritten with the values from other_hash
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @return [Hashlike] this hashlike, updated
#
# @overload hsh.update(other_hash){|key, oldval, newval| block}  -> hsh
#   Adds the contents of other_hash to hsh.  The value of each duplicate key
#   is determined by calling the block with the key, its value in hsh and its
#   value in other_hash.
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @yield  [Object, Object, Object] called if key exists in each hsh
#   @return [Hashlike] this hashlike, updated
#


# Hashlike#merge
#
# Returns a new hashlike containing the contents of other_hash and the
# contents of hsh. If no block is specified, the value for entries with
# duplicate keys will be that of other_hash. Otherwise the value for each
# duplicate key is determined by calling the block with the key, its value in
# hsh and its value in other_hash.
#
# @example
#     h1 = { :a => 100, :b => 200 }
#     h2 = { :b => 254, :c => 300 }
#     h1.merge(h2)
#     # => { :a=>100, :b=>254, :c=>300 }
#     h1.merge(h2){|key, oldval, newval| newval - oldval}
#     # => { :a => 100, :b => 54,  :c => 300 }
#     h1
#     # => { :a => 100, :b => 200 }
#
# @overload hsh.merge(other_hash)                               -> hsh
#   Adds the contents of other_hash to hsh.  Entries with duplicate keys are
#   overwritten with the values from other_hash
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @return [Hashlike] a new merged hashlike
#
# @overload hsh.merge(other_hash){|key, oldval, newval| block}  -> hsh
#   Adds the contents of other_hash to hsh.  The value of each duplicate key
#   is determined by calling the block with the key, its value in hsh and its
#   value in other_hash.
#   @param  other_hash [Hash, Hashlike] the hash to merge (it wins)
#   @yield  [Object, Object, Object] called if key exists in each hsh
#   @return [Hashlike] a new merged hashlike
#
